#### 7.4
写写开发日记。

首先遇到的第一个抉择点，是关于`steamAPI`的封装。说实话，我并不清楚封装到什么程度才算好的封装，原本打算像`axios`封装那样，封装成`url`,`params`。但是我想了想，这个网页其实只是用于展示一下我的游戏库，我并没有打算添加别的功能，或者别的与其他人交互的功能，毕竟我没有服务器，通过静态网页来调用接口还是不太安全（我可不想我的steam号被封了）。所以最终决定，封装到只有关于账号的参数，毕竟我打算把项目放到`github`上，别人用起来也方便点。

然后是关于`steamAPI`文件，里面有一些功能是我自己写的时候发现手动打比较重复且存在出错可能，叫AI帮我生成的。有一部分内容比较难以理解，以后我会补充相关知识点。

前几天我遇到了项目的第一个难题，当时我正在写`APIdemo`，打算尝试一下能不能跑通接口。为了规范性，我将测试用的`.js`文件改为了`.ts`文件。然后就出现问题了，无法运行ts文件，报错`Error [ERR_MODULE_NOT_FOUND]: Cannot find module`
这是因为脚本文件找不到模块，当时我检查了五六次，文件名是对的，后缀是`.ts`文件。值得注意的是，当时IDE有报错`只有在设置“noEmit”或“emitDeclarationOnly”时，才能使用选项“allowImportingTsExtensions”。`。很自然地，我也尝试将ts后缀删去后运行，仍然是找不到模版。

我向AI求助，它帮我新建了`config.ts`和`package.json`，并修改了里面的一些参数，它的目的是使文件可以导入`.ts`文件。
然而没有什么用，仍然是找不到模版。也尝试了将`.ts`编译为`.js`后再运行，还是相同的报错。
再三对话后，在我的要求下，`Gemini 2.5`给出了分析问题与调试错误的方法（而不是直接给出方案）。
通过调试，在单文件时，`.ts`文件是可以正常运行的，而一旦涉及多文件的`export`/`import`时，就会失灵，无论另一个文件有多么简单。这时我就知道问题并不在于文件本身，而是`export`/`import`，不过此时我并不知道根本原因是环境。

鉴于已经进行了多轮对话，AI的回答很可能出现幻觉，我就叫他把我们之间的对话以及遇到的问题，总结为一段`Prompt`，然后开了一个新的项目和AI，让他通过`Prompt`生成文件来针对遇到的问题进行调试。
不出意外地，问题成功复现了，AI还是那个样，生成`config.ts`和`package.json`后，让我使用`node loader ts-node/esm main.ts`，其实之前已经到过这一步了，仍然无法运行，AI再无推进。
我发现AI已经到极限后，上网查找了相关的问题，也没有找到正确答案，有一个关于ts脚本踩坑的，里面也有相同的报错，不过根本不是同一个问题。

此时，我又想起了IDE的报错`只有在设置“noEmit”或“emitDeclarationOnly”时，才能使用选项“allowImportingTsExtensions”。`。之前我跟AI提过这个错误的，但是他说这是IDE的滞后性的体现，别管。然后我就去网上查了`noEmit`和`emitDeclarationOnly`。
这涉及了TS的运行原理，在`noEmit`为`falsh`时，系统在运行`.ts`时，会先将其编译为`.js`文件，实际上运行的是`.js`文件。而当`noEmit`为f`true`时，则不会生成`.js`文件，他会即时编译`.ts`文件并运行。后者则是在`/disk`中生成声明文件而不生成`.js`文件。
我试着将两个都设置为`true`，运行，成功。

然后我追问了一晚上，终于搞明白了背后的原理。运行`.ts`文件有两条路，先编译成`.js`再运行和`.ts`直接运行。
第一条`noEmit = falsh`，通过`tsc`命令将`.ts`编译为`.js`，然后用`node`直接运行。值得注意的是，在这个方法中`.ts`文件中的导入文件必须以`.js`结尾，即使在编译前还没有`.js`文件。这是因为`node`根本不认识`.ts`文件，而我们在编译后得到的`.js`文件中，还是`.ts`，所以使用`node`运行会出错。
第二条`noEmit = true`，直接通过命令`node --loader ts-node/esm main.ts`。在不输出`.js`的基础上，相当于给`node`配了一个翻译官`--loader ts-node`，它会直接将关于`ts`的部分即时编译为`js`代码交给`node`，·`node`相当于还是在读`js`代码。此时导入文件必须以`.ts`结尾，这样这个翻译官才能知道这是需要他翻译的文件。

关于`ts-node`直接运行`.ts`文件，如果只是单文件还好，涉及多文件导入导出时，需要遵守`CJS`规范(`require`和`export`)，它与`ESM`(`import`和`export`)并不兼容。

我还问了怎么配环境，
1.`npm init -y`生成`package.json`（-y标志跳过所有提问，直接使用默认值）
2.`npm install`安装需要的包，像`typescript`，`ts-node`，`@type/node`等
3.创建`tsconfig.json`文件，可以自己写也可以通过命令`npx tsc --init`创建一个带注释的模版，然后修改配置
4.修改`package.json`，添加`"type":"module"`告诉`node`使用`ESM`规范，同时也可以添加一个`start`脚本

今天就写到这里了，这是最近的内容，明天要搬校区，后天要坐火车，下次再写。



#### 7.6
今天打算写请求脚本，在结构方面又出现了决策，为了解耦，我把调用接口的脚本都分开了，存储脚本的数据也都分开了。感觉有点麻烦或者说不必要，人教人教不会，事教人一遍会，大概碰到相关的屎山代码后我才能理解解耦的重要性吧。

今天还对一些嵌套调用出现了疑问。
当接口已经写了异步函数时，调用接口的函数需要写异步函数吗？答案是需要，因为不写的话函数还是不会等待返回的。

当接口已经`try`,`catch`捕获异常后，调用接口的函数还需要`try`,`catch`吗？这其实是关于错误处理策略。在`catch`中传入的参数`error`可以由自己抛出，也可以由js引擎、底层库抛出。`error`就像一个烫手山芋，如果函数没有处理`error`的方式，那么`error`就会被抛给父级函数处理，直至抛至全局环境导致程序崩溃。
不过如果在这个链条上有一个`catch{error}`，函数就会把`error`处理掉，它的调用者就不会知道`error`的存在。

由此衍生了两种常见模式：
1. 底层函数发现错误后默默处理，不再向上抛出错误，调用者不会知道具体是什么错误。
2. 底层发现错误并处理后，通过`throw error`向上抛出错误，告知调用者。

一个`Error`对象的核心结构:`name:string`、`message:string`、`stack:string`
关于`stack`属性，它是一个字符串，包含了错误的`name`、`message`，以及一个“堆栈跟踪”。堆栈跟踪会列出从错误发生点到`catch`块为止的所有函数函数调用层级，如
```
ReferenceError: myVar is not defined
    at functionB (/path/to/your/project/file.ts:15:5)
    at functionA (/path/to/your/project/file.ts:10:3)
    at Object.<anonymous> (/path/to/your/project/file.ts:20:1)
    ... (更多系统内部调用)
```

#### 7.9
最近几天有点忙。我发现自己写的效率有点低，很大程度上是因为，写着写着就忽然想加点什么功能，或者写个封装函数来方便调用什么的。然而实际上却拖慢了开发进度，我认为，这是因为没有想好自己要做一个怎样的系统，在安全性、稳定性、可维护性等地方的指标没有确立下来，对项目没有一个具体目标导致的。

就以今天为例，我在写脚本时，突然就想到了，是不是应该进行类型检查，问了AI，觉得它的方案太简单了，基本上就是照搬pojo里面的结构。
然后我就要求它生成一个复用性高点的，于是它就生成了一个类型守卫函数。那个函数仍然存在不够完善的地方，只能检查基础类型，我就又继续要求，它继续生成。
这次生成的函数我很满意，然后我今天就只是自己按照它的思路自己重新写了次那个函数，然后就没了。

虽然在开发过程中学习了不少知识，但这种想到啥做啥的开发模式还是太低效了。

我打算采用敏捷开发的方式，先运行再优化，即使架构也是这样，那些打算写的函数和封装就先放到todo list里面，等开发完后再完善

刚刚将开发日志给ds看了看，让他帮我分析分析我现在存在什么问题，以及解决方法

三个问题
1.功能蔓延：开发中不断添加非核心功能
2.过早优化：在验证核心流程前追求完美解决方案
3.注意力分散：被技术细节带离开发主线

敏捷开发
核心功能MVP -> 验证可行性 -> 收集反馈 -> 迭代优化

通过目标冻结法和技术债管理来加速开发流程

#### 7.20
前几天写了html框架和一部分css样式，刚回到姥爷家不久，最近一个月应该是可以保证每天都写写的。

哦哦，昨天我还新加了一个脚本，说实话，需求其实只有一个展示游戏，很显然，其实只需要一个json文件就可以了，而且全部游戏和最近游戏其实是一个包含和被包含的关系，完全重复了，需求分析这一块鉴定为不及格。

前后端分离是正确的，太愚蠢了之前，居然还觉得数据处理这部分内容是属于前端，所以就没有分离开。技术栈也显然有问题，h5配合ts对我来说实在有点太难了。。。之前写tsx写得挺舒服的，大概率是由于脚手架已经配好环境了的原因。

ok，今天前后端分离后，成功加载出了库存的图片，很高兴。

总结一下今天遇到的问题
1.试图链接js文件，失败。原因：其实并非环境的锅，是对h5的不熟悉，不熟悉script标签以及导入导出规则
2.在链接失败后，重新编译，由于之前对于ts脚本文件采用了不生成js文件的方式，需要重新配置环境。
又因为配置环境需要大改，故考虑前后端分离。
（不知道h5的`script`标签能否使用ts文件，我自以为不能了，还没验证，一会儿问问）
3.将先前的脚本代码全部划分为后端部分，将data存储位置划分至前端src目录下
4.重新配置前端，并使用npx tsc编译ts文件

知识点：
1.cjs动态加载，使用exports,require导入导出。esm静态加载，使用export，import导入导出
2.重复函数报错。当ts文件不使用export时，会默认为全局脚本，此时在其他地方如果也有相同命名的函数，就会报错。解决方法是使用export{}来将文件强制转换为“模块”作用域。
3.npx tsc命令在编译时，会在当前文件夹内寻找配置文件，找不到则会一直向上查找，在前后端分离后我没有第一时间配置前端环境，这在一定程度上造成了配置混乱。
4.fetch的查找路径有两种，`./`开头是当前文件夹开始 `/`开头是`src`文件夹开始

5.`script`标签工作原理，在读到后会停止会html的后续解析，并通过src发起一个网络请求，下载相应的js文件并执行，执行完毕后继续解析html。由于我的js代码涉及DOM节点操作，故放在html文件的最后，一是方便加载，二是确保DOM节点存在。
6.`script`标签中可以直接写js代码，不过不推荐，可维护性、可重用性以及浏览器缓存是不推荐的原因
7.`script`标签中，使用`type = moudle`告诉浏览器这是一个模块脚本，模块脚本支持`import`,`export`。并且，模块化标签的作用域是只在模块内部

### 7.22
今天实现的功能：
1.游戏库的滚动展示
通过将游戏库进行水平拼接，设游戏库为A,拼接为 A | A，然后将通过css属性 animation:scroll 60s linear infinite实现水平滚动。接着定义关键帧，
通过@keyframes scroll{ to{ transform:translateX(calc(-50% - 0.5rem))} }，实现在动画100%完成度时，将元素向左平移，实现无限水平滚动
对于数量带来的可能的图像不规则问题，选择只排列一行，一条长长的水平线

2.动态填充统计数据
通过js进行DOM节点操作，在遍历json数据并将其转换为图标时，顺便统计最近游戏时长等数据，优化时间。在第二次遍历写出列表时，就可以通过之前获得的数据构造进度条，为了避免过长的游戏时间导致大部分游戏的进度条较短，使用了对数来计算百分比。

### 7.23
因为最近玩游戏发现经常要合成东西，计算原料，上网查找发现居然没有类似的工具，就要求AI生成一个。上午的时间主要用于对那个项目的调试以及配置环境，AI现在的能力确实无法避免人工介入。虽然生成的很快，效果看起来也不错，基本功能也实现了，但是和我的目标有一定的差距，计划一天迭代一个版本，希望一个星期后我能用上那个计算器。

### 7.25
今天和AI一起对前端代码进行code review，问题还挺多的。

HTML:
原先我的代码存在许多地方使用id来划分标签，这导致了CSS中也存在许多的ID选择器。与此同时，我的类命名也并不规范。还存在部分内容不被标签包裹的现象。
经过优化，现在已经确保了所有内容都有标签包裹，并且标签也都通过组件化的方式进行命名。

CSS：
太乱了，原先没有按照组件化的思路，经常东一块西一块，维护性很差。同时，对于一些内容，不存在大小规范之类的，写出来的内容虽然排版和功能都实现了，但是配色太烂了。
经过优化，现在实现了组件化CSS了，同时也优化了配色，给很多按钮增加了伪类选择器:hover，也添加了对于大小的规范
（不过AI的CSS还是存在许多问题，需要自己动手修改）

JS:
原先看起来很乱，也是东一块西一块，模块化了但是没有完全模块化。存在职责分离不完全，全局变量影响，DOM节点重复查询，事件监听器代码未封装等问题。
经过优化，已经解决了上述的问题。集中DOM节点操作，将数据统计的功能从库循环展示的那个函数中分离出来，把全局变量砍掉，用一个main函数内定义的对象存储，封装类似操作。

在这中间，我还学到了很多知识点，像是用reduce迭代遍历，增加padding使图片放大时不会被高度"拦截"等。

### 7.26
今天对项目进行了一点优化，以及对昨天内容的查漏补缺。
最大的收获是对js的进一步理解，之前一直只知道一句话，在JS中，所有对象都是引用。这让我误以为所有变量也都是引用，所以在写节流状态锁时，直接将状态传了进去，然后在函数里面对状态进行修改。但是实际在网页却没有表现出我想要的效果，问题仍然存在。
后面才知道，变量是变量，对象是对象，js只有值传递而没有引用传递，即使对象也是因为实际传递的是地址才出现了引用传递这样的现象。
那么解决方法就很简单了，一是把状态锁外置，函数只负责执行，二是传入状态对象，像`{a}`这样，那么我传入的不是状态变量`a`，而是包含状态变量`a`的对象。
现在打算学习CI/CD流水线，有一说一，这个项目还有想要优化的，但是我想去写前几天的那个配方工坊项目了，那个很有趣，也很具有挑战性，同时也很实用，我不想让AI直接生成一大段一大段把那个项目敷衍过去了。

CI/CD中，怎么检查代码的？检查什么了？ 
—— 主要是三个方面 1.代码风格和格式 2.单元测试 3.类型检查
uses和run有什么区别？
 —— use使用封装好的action脚本，run自己输入命令行（使用|输入多行）
CI/CD上传时会不会触发？ 
—— 会
为什么要准备部署的产物？ 
—— 两个job可以想象为在两台隔离的虚拟机上运行的
如何将build任务的成果交给deploy任务 
—— 使用`uses: actions/upload-pages-artifact@v3`,配合`with`传入地址可以将文件上传到临时存储空间。被上传的包称为Artifact
environment和url是什么？
—— environment是用于管理和保护部署环境的功能，`name`可以声明任务将要部署到一个怎么样的环境。（现在的设置是一个特殊名称）
`url: ${{steps.deployment.outputs.page_url}}`则是一个特殊的输出变量，会产生一个output，作用是把地址显示再工作流的摘要页面上，方便点击访问
网上看到branch和folder是什么，为什么没见到？
—— 过时的部署方法，不推荐。现在的流程`upload-pages-artifact` + `deploy-pages`更干净更简单

关于git的操作
git remote -v 
git remote add origin_name url
git remoye set-url origin_name new_url
git branch -m new_branch_name
git pull origi_name branch_name

明日任务：手机端适配




